**面向对象**:不断创建对象，指挥对象做事情
·面向过程：把大象装进冰箱，打开冰箱门、装进大象、关上冰箱门
·面向对象：把大象装进冰箱，冰箱门打开，大象走进去，冰箱门关闭，对象是冰箱门和大象，冰箱门open()\close(),大象in()
属性+行为=一件事物>>>>类：一组相关属性和行为的集合
·类：人，属性（成员变量）：人的身高和体重等，行为（成员方法）：学习、吃饭等
**************************************************
·类：可以理解为构造对象的一个蓝图或者模版，是抽象的概念*
·对象：是以类为模型创建的具体实例，是对类的一种具体化。*
**************************************************
举例：类是学生的话，对象可以是具体的某一个学生比如班长（new 对象）
·创建对象：类名 对象名 = new 类名(); 对象名.成员变量 对象名.成员方法
**内存**？？？？
·成员变量堆内存，局部变量栈内存，成员变量有默认的初始值，局部变量没有必须定义赋值才能使用
·匿名对象：不设置对象名字，new Student().show();
**封装**
·封装：是指隐藏对象的属性和实现细节，仅对外提供公共访问方式，private是一种封装
被private修饰的成员只能在本类中才能访问，提供对应getxxx()/setxxx()的方法
·this：代表所在类的对象引用
·super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。
·this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。
this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。
从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。
·构造方法：给对象的数据进行初始化，方法名与类型相同，没有返回值类型（连void都没有），因此没有具体的返回值
如果你不提供构造方法，系统会给出默认构造方法，如果你提供了构造方法，系统将不再提供，构造方法也是可以重载的
给成员变量赋值的方式：无参构造方法+setXxx()；带参构造方法
一般来讲，没有构造方法的类成员一般是静态的。构造方法可以重载不可重写。 
实例构造器只能在new表达式（或别的构造器）中被调用，不能通过方法调用表达式来调用。new表达式作为一个整体保证了
对象的创建与初始化是打包在一起进行的，不能分开进行；但实例构造器只负责对象初始化的部分，“创建对象”的部分是由new表达式本身保证的。 
·static关键字 详解见https://www.cnblogs.com/dolphin0520/p/3799052.html 
由于静态方法不依赖于任何对象就可以进行访问，静态方法是没有this关键字的方法，方便在没有创建对象的情况下来进行调用（方法/变量）
静态内容是所有对象!!共享的，非静态内容是各个对象特有的。
在静态方法中不能访问非静态成员方法和非静态成员变量，但是在非静态成员方法中是可以访问静态成员方法/变量的。静态变量可以通过类名调用，也可以通过对象调用
如果说想在不创建对象的情况下调用某个方法，就可以将这个方法设置为static，例如main()
但是在Java中切记：static是不允许用来修饰局部变量！！！只能修饰类成员变量/方法 普通成员变量只能通过对象名调用
static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。
%%%经典面试题%%%
public class Test {
    Person person = new Person("Test");
    static{
        System.out.println("test static");
    }
     
    public Test() {
        System.out.println("test constructor");
    }
     
    public static void main(String[] args) {
        new MyClass();
    }
}
 
class Person{
    static{
        System.out.println("person static");
    }
    public Person(String str) {
        System.out.println("person "+str);
    }
}
 
 
class MyClass extends Test {
    Person person = new Person("MyClass");
    static{
        System.out.println("myclass static");
    }
     
    public MyClass() {
        System.out.println("myclass constructor");
    }
}

test static
myclass static
person static
person Test
test constructor
person MyClass
myclass constructor
类似地，我们还是来想一下这段代码的具体执行过程。首先加载Test类，因此会执行Test类中的static块。接着执行new MyClass()，
而MyClass类还没有被加载，因此需要加载MyClass类。在加载MyClass类的时候，发现MyClass类继承自Test类，但是由于Test类已经
被加载了，所以只需要加载MyClass类，那么就会执行MyClass类的中的static块。在加载完之后，就通过构造器来生成对象。而在生成
对象的时候，必须先初始化父类的成员变量，因此会执行Test中的Person person = new Person()，而Person类还没有被加载过，因
此会先加载Person类并执行Person类中的static块，接着执行父类的构造器，完成了父类的初始化，然后就来初始化自身了，因此会接着
执行MyClass中的Person person = new Person()，最后执行MyClass的构造器。

**继承** class 子类名 extends 父类名{}
通过关键字extends实现类与类的继承






