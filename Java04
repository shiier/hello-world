**面向对象**:不断创建对象，指挥对象做事情
·面向过程：把大象装进冰箱，打开冰箱门、装进大象、关上冰箱门
·面向对象：把大象装进冰箱，冰箱门打开，大象走进去，冰箱门关闭，对象是冰箱门和大象，冰箱门open()\close(),大象in()
属性+行为=一件事物>>>>类：一组相关属性和行为的集合
·类：人，属性（成员变量）：人的身高和体重等，行为（成员方法）：学习、吃饭等
**************************************************
·类：可以理解为构造对象的一个蓝图或者模版，是抽象的概念*
·对象：是以类为模型创建的具体实例，是对类的一种具体化。*
**************************************************
举例：类是学生的话，对象可以是具体的某一个学生比如班长（new 对象）
·创建对象：类名 对象名 = new 类名(); 对象名.成员变量 对象名.成员方法
**内存**？？？？
·成员变量堆内存，局部变量栈内存，成员变量有默认的初始值，局部变量没有必须定义赋值才能使用
·匿名对象：不设置对象名字，new Student().show();
**封装**
·封装：是指隐藏对象的属性和实现细节，仅对外提供公共访问方式，private是一种封装
被private修饰的成员只能在本类中才能访问，提供对应getxxx()/setxxx()的方法
·this：代表所在类的对象引用，this(...),super(...)访问构造方法。
·super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。
·this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。
this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。
从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。
·构造方法：给对象的数据进行初始化，方法名与类型相同，没有返回值类型（连void都没有），因此没有具体的返回值
如果你不提供构造方法，系统会给出默认构造方法，如果你提供了构造方法，系统将不再提供，构造方法也是可以重载的
给成员变量赋值的方式：无参构造方法+setXxx()；带参构造方法
一般来讲，没有构造方法的类成员一般是静态的。构造方法可以重载不可重写。 
每一个构造方法的第一条语句默认都是：super()。
实例构造器只能在new表达式（或别的构造器）中被调用，不能通过方法调用表达式来调用。new表达式作为一个整体保证了
对象的创建与初始化是打包在一起进行的，不能分开进行；但实例构造器只负责对象初始化的部分，“创建对象”的部分是由new表达式本身保证的。 
·static关键字 详解见https://www.cnblogs.com/dolphin0520/p/3799052.html 
由于静态方法不依赖于任何对象就可以进行访问，静态方法是没有this关键字的方法，方便在没有创建对象的情况下来进行调用（方法/变量）
静态内容是所有对象!!共享的，非静态内容是各个对象特有的。
在静态方法中不能访问非静态成员方法和非静态成员变量，但是在非静态成员方法中是可以访问静态成员方法/变量的。静态变量可以通过类名调用，也可以通过对象调用
如果说想在不创建对象的情况下调用某个方法，就可以将这个方法设置为static，例如main()
但是在Java中切记：static是不允许用来修饰局部变量！！！只能修饰类成员变量/方法 普通成员变量只能通过对象名调用
static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。
%%%经典面试题%%%
public class Test {
    Person person = new Person("Test");
    static{
        System.out.println("test static");
    }
     
    public Test() {
        System.out.println("test constructor");
    }
     
    public static void main(String[] args) {
        new MyClass();
    }
}
 
class Person{
    static{
        System.out.println("person static");
    }
    public Person(String str) {
        System.out.println("person "+str);
    }
}
 
 
class MyClass extends Test {
    Person person = new Person("MyClass");
    static{
        System.out.println("myclass static");
    }
     
    public MyClass() {
        System.out.println("myclass constructor");
    }
}

test static
myclass static
person static
person Test
test constructor
person MyClass
myclass constructor
类似地，我们还是来想一下这段代码的具体执行过程。首先加载Test类，因此会执行Test类中的static块。接着执行new MyClass()，
而MyClass类还没有被加载，因此需要加载MyClass类。在加载MyClass类的时候，发现MyClass类继承自Test类，但是由于Test类已经
被加载了，所以只需要加载MyClass类，那么就会执行MyClass类的中的static块。在加载完之后，就通过构造器来生成对象。而在生成
对象的时候，必须先初始化父类的成员变量，因此会执行Test中的Person person = new Person()，而Person类还没有被加载过，因
此会先加载Person类并执行Person类中的static块，接着执行父类的构造器，完成了父类的初始化，然后就来初始化自身了，因此会接着
执行MyClass中的Person person = new Person()，最后执行MyClass的构造器。

**继承** class 子类名 extends 父类名{}
    通过关键字extends实现类与类的继承
    java支持单继承、多层继承，不支持多继承。
    子类只能继承父类所有非私有成员方法及成员变量，不能继承父类的构造方法，可以通过super去调用父类带参的构造方法。
子类的所有构造方法默认都会访问父类中空参的构造方法（每一个构造方法的第一条语句默认都是：super()），子类初始化之前，一定要先完成父类数据的初始化。如果父类没有无参构造函数
创建子类时，不能编译，除非在构造函数代码体中第一行，必须是第一行显式调用父类有参构造函数。（创建有参构造函数后，系统就不再
有默认无参构造函数。如果没有任何构造函数，系统会默认有一个无参构造函数。）
    创建子类对象，会先去访问父类的构造方法，对父类的数据进行初始化。
    先父后子，无论是加载类还是初始化过程。
    static代码块只执行一次，super()只执行一次。静态代码块>>>>构造代码块>>>>>构造方法
**方法重写** 子类中出现了和父类一样的方法声明。
    当子类需要父类的功能，而功能主体子类有自己特有内容时，可以重写父类中的方法，这样，即沿袭了父类的功能，又定义了子类特有的内容。
    注意：父类中private的方法不能被重写
·final关键字：可以修饰类，成员方法及变量。修饰类，类不能被继承；修饰变量，变量成常量，只能被赋值一次；修饰方法，方法不能被重写。
final初始化时机：1.在定义的时候立刻赋值，之后不能改动。 2.定义以后，构造方法结束前赋值。

**多态**  理解参考：https://www.zhihu.com/question/30082151
转型问题：1.向上转型：父类引用指向子类对象2.向下转型：父类引用转为子类对象
多态的存在有三个前提:1.要有继承关系 2.子类要重写父类的方法（因为父类的方法可能是抽象的不能实例化） 3.父类引用指向子类对象,
成员访问特点：成员变量编译看左边(父类)，运行看左边（子类）
             （非静态）成员方法编译看左边，运行看右边
             静态方法编译看左边，运行看左边
强制转换：Cat ct = (Cat)am;//Animal am = new Cat();父类引用指向子类对象，语句在堆内存中开辟了子类(Cat)的对象，并把栈内存中的父类(Animal)的引用指向了这个Cat对象。
·抽象类（共性功能）：一个没有方法体的方法称为抽象方法，有抽象方法的类称为抽象类,然而抽象类未必有抽象方法
格式：abstract class 类名{} public/private abstract void name();
抽象类不能实例化，即不能创建对象，只能由非抽象的具体的子类实例化。其实这也是多态的一种，抽象类多态。
final修饰的方法不能被重写，abstract修饰的方法必须被重写。
·接口 主要是扩展功能。没有具体存在
格式：interface 接口名{}
类实现接口格式： class 类名 implements 接口名{}
接口不能实例化，只能由具体的子类实例化。其实这也是多态的一种，接口多态。
接口的子类：要么是抽象类；要么重写接口中的所有抽象方法。
接口成员变量只能是静态常量，默认public static final，没有构造方法，只有抽象成员方法，没有方法体，默认public abstract
类与类：继承关系，只能单继承。可以多层继承。
类与接口：实现关系，可以单实现，也可以多实现。还可以在继承一个类的同时实现多个接口。
接口与接口：继承关系，可以单继承，也可以多继承。
？？接口的意义： 参见https://www.zhihu.com/question/20111251

**包**对类进行分类管理
格式：package 包名；
package语句必须是程序的第一条可执行的代码
package语句在一个java文件中只能有一个
如果没有package，默认表示无包名
导包：import 包名.类名

·内部类：把类定义在其他类的内部
内部类可以直接访问外部类的成员，包括私有。
外部类要访问内部类的成员，必须创建对象。
成员内部类格式：外部类名.内部类名 对象名 = new 外部类对象.new 内部类对象
局部内部类:访问局部变量必须被final修饰。可以直接访问外部类的成员；可以创建内部类对象，通过对象调用内部类方法，来使用局部内部类功能。
num/this.num/Outer.this.num
匿名内部类：new 类名或接口名{ 重写方法；}（必须重写所有接口里的抽象方法）
 本质是一个继承了类或者实现了接口的子类匿名对象







